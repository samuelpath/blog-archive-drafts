![FCC logo](http://www.samuelpath.com/wp-content/uploads/2017/06/FCC-logo.png)

Two months ago, I shared [my first steps building static web pages with Free Code Camp](http://www.samuelpath.com/fcc-static/) (FCC). The two little projects I mentionned were useful to get a first grasp of HTML and CSS and their interactions (as well as the [Bootstrap](http://getbootstrap.com/) framework).

However, I'm personally much more interested by the Javascript part of web development. It's the logic and behavior aspects that get me on fire. That's why I just did the minimum required to validate the static pages little projects so that I could move on to the Javascript part.

And I was not disappointed.

The next main section in the [FCC's Front End Development Certification](https://www.freecodecamp.com/map) is called Algorithm Scripting and contains 46 exercises divided in 3 levels: basic, intermediate and advanced. The campers call these challenges "bonfires" (to continue the camp metaphor of course).

![FCC bonfires curriculum](http://www.samuelpath.com/wp-content/uploads/2017/06/map.png)

According to FCC's maintainers, someone starting to learn JavaScript with FCC should take 50 hours to solve each level, which means that this requires 150 hours (about a month of full-time work). But of course, for someone already familiar with other languages or with JS itself (which was my case), this can go much faster.

# What are these challenges about?

Each challenge is layed out in the same way. See below a screenshot of the first challenge (here's a [link](https://www.freecodecamp.com/challenges/reverse-a-string) to the challenge itself):

![FCC challenge image](http://www.samuelpath.com/wp-content/uploads/2017/06/challenge.png)

On the left, you've got the basic instructions, followed by some documentation links to concepts or JavaScript methods that could be useful in solving the problem. Then you've got the interaction buttons (run the tests, reset the test, ask for help in the chat room, report a bug) and a browser console for debugging purposes. And on the right, you've got the built-in code editor.

The basic level section starts very lightly with challenges such as how to [reverse](https://www.freecodecamp.com/challenges/reverse-a-string) or [truncate](https://www.freecodecamp.com/challenges/truncate-a-string) a string, [factorialize a number](https://www.freecodecamp.com/challenges/factorialize-a-number) or [return the largest numbers in arrays](https://www.freecodecamp.com/challenges/return-largest-numbers-in-arrays). This section is a really good way to get a first exposure to basic JavaScript syntax and built-in methods (like from the [String](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/prototype) and [Array](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype?v=control) prototypes). It's perfect for developers familiar with other languages and complete beginners alike.

The intermediate section asks for more algorithmic reflection, and starts to require at least some basic mathematical reasoning. For instance you're asked to [sum all odd fibonacci numbers](https://www.freecodecamp.com/challenges/sum-all-odd-fibonacci-numbers), get the [sorted union of numbers in an unspecified number of arrays](https://www.freecodecamp.com/challenges/sorted-union), or translate strings to [pig latin](https://www.freecodecamp.com/challenges/pig-latin). Here memories of your high school math classes will come in handy.

The advanced level section contains only 9 exercises, but you'll need to up your game in order to solve them. For instance you'll need to create complex regular expressions in order to [validate US telephone numbers](https://www.freecodecamp.com/challenges/validate-us-telephone-numbers), calculate the [exact change to be be returned to a customer at a cash register](https://www.freecodecamp.com/challenges/exact-change) or [compute the symmetric difference between any number of arrays](https://www.freecodecamp.com/challenges/symmetric-difference).

Also, for each challenge, there's a page in the [FCC's forum](https://forum.freecodecamp.com/t/freecodecamp-algorithm-challenge-guide-symmetric-difference/16086) giving hints and offering 3 solutions: one necessitating basic skills, one intermediate and one advanced. To find it, simply enter the challenge's name in the forum's search bar. Here's for instance the page for the [Symmetric Difference problem](https://forum.freecodecamp.com/t/freecodecamp-algorithm-challenge-guide-symmetric-difference/16086).

# So... why should *you* tackle them?

Frankly, tackling these challenges provided me with tons of fun *and* frustration, and allowed me to improve my coding skills.

## Fun... really?

At times, I worked for hours on end without seeing time pass, as I moved on from simple challenges to increasingly complex ones. I was in what psychologists call a state of flow. The [Wikipedia](https://en.wikipedia.org/wiki/Flow_(psychology)) definition of it aptly describes my experience:

> The mental state of operation in which a person performing an activity is fully immersed in a feeling of energized focus, full involvement, and enjoyment in the process of the activity. In essence, flow is characterized by complete absorption in what one does and loses sense of space and time.

![Person working on laptop on a roof](http://www.samuelpath.com/wp-content/uploads/2017/06/rooflaptop.jpg)

Flow is fun and flow brings happiness. So first of all, tackling these challenges can make you happy :).

## Frustration

At other times, I got stuck for long hours. I would try to find a working algorithm on paper, see that it would lead me nowhere, and tear the page in frustration, to start over from scratch. Over and over.

FCC encourages the campers to get help (see their [Read-Search-Ask](https://github.com/FreeCodeCamp/freecodecamp/wiki/FreeCodeCamp-Get-Help) problem solving framework), but I must confess that I absolutely wanted to solve these challenges by myself. I didn't even allow myself to check Google, except to see the signature of a particular built-in JS method. During these times, I sometimes wanted to bang my head against the wall or scream out of frustration.

![Person breaking computer screen out of frustration](http://www.samuelpath.com/wp-content/uploads/2017/06/StressAndFrustration.jpg)

When this happens to you, know that you are not alone. Simply breathe, relax, take a walk, and come back to the challenge another time. Finally, by persistence, I always found a working solution. This is good developer training, since being a developer requires to be comfortable with being stuck and feeling lost.

## Coding skills improvement

Solving coding challenges is one of the most effective ways to learn algorithms and language syntax. Even now as a professional developer, I can spend days working on tasks that don't really challenge my coding skills. Sure, I often need to understand complex systems, get deep in the codebase to solve a customer ticket, or configure various tools.

In many developers jobs, you won't have to use a lot of algorithmic skills *daily*. Solving challenges is a form of intentional practice. If you do them, you will become better and more proficient no matter what. You are not in auto-pilot mode. You tackle increasingly complex challenges that get you out of your comfort zone.

It's like practicing your katas in karate. You need to practice by yourself in order to be ready for the fights.

![Karate kata](http://www.samuelpath.com/wp-content/uploads/2017/06/karate.jpg)

When you're done with a challenge, you can see the solutions offered on the forum's page. And frankly, this is oftentimes a terribly humbling experience. Once you have a working solution that you've refined a bit, you rightly feel some kind of pride. But by seeing how much more elegant and efficient these solutions are, you can learn from them and see how much progress you can still make as a developer.

# Here are my solutions

A few weeks ago, I decided to put all the code I've written on my own time on my [Github profile](https://github.com/samuelpath). Putting my code in public forces me to make sure that my code meets some minimal quality criteria.

I'm currently in the process of importing my code. It takes quite some time since when I see code I've written in the past, I can't help but try to improve and refactor it by using everything I've learnt since. Here are my [solutions to these challenges](https://github.com/samuelpath/free-code-camp/tree/master/JS-algorithm-scripting).

I initially solved them 9 months ago in September 2016, and I've been very happy lately to see how much progress I've made since then. For almost every challenge, I could use my improved skills to do things more elegantly, concisely and cleanly.

I've also stumbled upon code that I've written that was so confused that even I struggled to understand what I meant. So my focus has been not only to make my code more intelligent, but also more *intelligible*.

# Now your turn

If you haven't solved coding challenges lately, I strongly encourage you to take some time each week to go through these exercises. It will make you a happier and better coder :).

If you've already worked on them, I welcome your feedback on this experience.